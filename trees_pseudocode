Tree data structure:
--------------------

Create a node class
    Class node
        __init__ with value/data as input
            self.value/data
            self.left
            self.right

        The __str__ function must always return a string

        __str__ with self as input
            ret = str(self.value)
            ret += ' left: ' + str(self.left.value) if self.left is not None else "None"
            ret += ' right: ' + str(self.right.value) if self.right is not None else "None"
            return ret

Create a Binary Search Tree class that will use the node class
In __init__ set self.root = None
Add a create method that accepts a value/data - time complexity O(logN) where N is number of nodes in tree
    if self.root is None
        self.root = Node(value/data)
    else
        Set current to self.root
        while True
            if value < current.value
                if current.left is not None
                    current = current.left
                else
                    current.left = Node(value)
                    break
            else if value > current.value
                if current.right is not None
                    current = current.right
                else
                    current.right = Node(value)
                    break
            else
                break

There are two types of tree traversal:

Depth First Search - which uses a stack
Breadth First Search - which uses a queue


Depth First                 Breadth First
-----------                 -------------
1. Pre-Order                1. Level-Order
2. In-Order
3. Post-Order

==========
Pre-Order:

Time complexity is O(n) because we visit each node once

1. Visit Node
2. Traverse Left
3. Traverse Right

Pseudocode:

preorder(node)
    if node == null then return
    visit(node)
    preorder(node.left)
    preorder(node.right)

=========
In-Order:

Time complexity for inorder is O(n) since you visit each node once

1. Traverse left
2. Visit node
3. Traverse right

Pseudocode:

inorder(node)
    if node == null then return
    inorder(node.left)
    visit(node)
    inorder(node.right)

===========
Post-Order:

Time complexity is O(n) because we visit each node once

1. Traverse Left
2. Traverse Right
3. Visit Node

Pseudocode:

postorder(node)
    if node == null then return
    postorder(node.left)
    postorder(node.right)
    visit(node)

============ Breadth First instead of Depth First
Use an iterative approach rather then recursive, the above were all recursive

Level-Order:

Time complexity is O(n) because we visit each node once
Pseudocode:
level_order(root)
    q <- empty queue
    q.enqueue(root)
    while (not q.isEmpty())
        node <- q.dequeue()
        visit(node)
        if (node.left != null)
            q.enqueue(node.left)
        if (node.right != null)
            q.enqueue(node.right)

Trie data structure:
--------------------
A trie can be implemented with a dictionary in the __init__ function. Each letter in the dictionary will
also have a count of the number of words that are linked with this letter. Determine some character to
use to signify the end of a word, e.g. '*'

Initialization self.root <- {} - a defaultdict would work as well
Create an add method
    Set current node to self.root
    for letter in incoming word
        if letter is NOT in current node
            add letter to current node with {"count":0}
        Set current node to current_node[letter]
        Increment the "count" for the letter by 1
    When done adding word, add the word terminator character to current node and set its value to True

Create a search method that will look for whole words
    Accept a word as input
    Set current node to self.root
    For letter in supplied partial
        if letter not in current node
            return False
        Set current node to current node[letter]
    If we reach the end of the search value but are not at the end of a word
        return False
    else
        return True

Create a prefix method
    Accept a prefix as input
    Set the current node to self.root
    for letter in prefix
        if letter not in current node
            return False
        Set current node to current node[letter]
    At end of for loop, return True

Create a count partial method that will return the number of words in the trie that contain the partial
    Accept a partial, i.e. prefix, as input
    Set the current node to self.root
    for letter in partial
        if letter not in current node
            return 0
        Set current node to current node[letter]
    return current node['count']

Hacker Rank Challenges:
-----------------------

Contacts:

Create a function that will create/use a trie to store any provided contacts and allow for
finding any contacts that are in the trie. A list of queries will be provided to the function
that are in the format: (query type, value). The query type can be either "add" or "find".

Accept a list of queries as input
Create a trie
Set up a results list
for query in queries
    if type is add
        trie.add query value
    else if type is find
        trie.find query value
        If found append value to results
    return results

Height of a Binary Tree:

Create a function that contains a function that can be used recursively to determine the height of a
binary tree. The outer function will accept a tree as input. The inner function will take the current
node as well as the current height as input.

Outer function height takes a tree as input
    Inner function __height__ takes current node and current height as input
        If the current node is None
            return the current height
        Set left height to call to inner function with current node .left and current height + 1
        Set right height to call to inner function with current node .right and current height + 1
        return the max of left height or right height
    return __height__ root, -1

Swap Nodes:

The idea behind this challenge is to swap nodes in a binary tree based on being at the correct
level based on the value provided.

Create a function, swap nodes, that will take a list of indexes/nodes to create and
